---
title: "Designing the “Quick Quote” Experience in Agent Portal"
date: 2017-08-19
tags: designProcess insight
---

A few months back, I got the task of designing a new “quick quote” interface for our insurance quoting application. We’re currently on a legacy platform where the primary quoting experience of the application is played out through our flash player. The problem is flash is dying...fast. So one of the goals of our platform has been to incrementally draw out primary application pieces built in flash and rebuild them in web technologies. One of the most frequently used features of our flash player is the “Start a New Quote” experience, so we decided to rebuild that experience in web technologies. Now, rather than having to do 100% of the quoting experience through the flash player, users only have to do about 90% of it in flash (the first 10% being the experience i’ll outline below).

## Iteration No. 1

We have enough information to start providing a quote to users once we have one thing: the address of the property. Everything else we can guess at and provide a “recommended” insurance product. However, we figured that if user’s prefer, they can always choose the insurance product themselves. That reasoning is how we arrived at the first iteration of the quick quote experience, which went something like the following.

In the header of the application there is a “New Quote” button which opens our quick quote experience in a “zero state” like this:

![First iteration screenshot for starting a new quote]({{ site.imageurl }}/2017/qqs-v1-start.png "Zero state when starting a new quote (v1)")

If the user (agent) chooses “By Property”, we provide an address autocomplete that leverages the Google API to lookup in address in natural language. 

![First iteration screenshot for the address selection when starting a new quote]({{ site.imageurl }}/2017/qqs-v1-property-step-1.png "Address autocomplete")

Once an address is found, the rest of the form will render with “smart” defaults so they can quickly be on their way to starting a new quote.

![First iteration screenshot for smart defaults]({{ site.imageurl }}/2017/qqs-v1-property-step-2.png "With just the address, the form is ready to be submitted")

At this point, the user would be allowed to submit the form. The server would do its work and respond back by informing the client whether or not a product was available. In some cases, there were more than one products, so we would provide the option to choose which product they preferred.

![First iteration screenshot for 1+ products]({{ site.imageurl }}/2017/qqs-v1-property-step-3.png "Covering an edge case of 1+ products")

There was also a case where no products would be available. For this edge case we asked the user to provide us more details so we could learn more about what they were looking for, which would help us as a business ask why we are not providing products customers are looking for.

![First iteration screenshot for 0 products]({{ site.imageurl }}/2017/qqs-v1-property-step-4.png "Gather further feedback when we couldn’t provide what the user was looking for")

As an alternative to starting a quote with an address (or if an address couldn’t be found) I designed a toggle that served as a way to quickly “switch” between the two primary methods for starting a new quote. The “By Product”  toggle would render a different UI.

![First iteration screenshot for starting a quote by choosing a property]({{ site.imageurl }}/2017/qqs-v1-product-step-1.png "Start a new quote by specifying the insurance product you want")

Once you chose a carrier, you’d be provided the associated options for choosing your product. From there, you could start a quote (and you’d fill in the rest of the details inside the flash player experience).

![First iteration screenshot for starting a quote by choosing a property]({{ site.imageurl }}/2017/qqs-v1-product-step-2.png "Different options would automatically fill in based on your choices")

## Iteration No. 2

As we reviewed these mocks and talked about how this all played out, we realized that we were unnecessarily breaking up the flow into two categories (“By Property” and “By Product”). Why couldn’t they just be the options of the form, without the user having to be aware of the distinction? That’s what we tried to do in a quick second iteration. We allowed the different options to play out dynamically in a single form.

![Second iteration screenshot for starting a new quote]({{ site.imageurl }}/2017/qqs-v2-example.png "A combination of all UI choices from the first iteration in a single form")

Note that these are the same choices from the first iteration. They are merely presented in a single form without the extra overhead of categorization. The categories didn’t really matter to the end user. **We realized the UI categories we had created were really an outworking of us coming to understand our own internal systems and processes.** So we stripped them out.

Here’s an example of how this played out depending on form choices:

![Second iteration animated gif for starting a new quote]({{ site.imageurl }}/2017/qqs-v2-flow.gif)

## Iteration No. 3




---

There's this thing called QQS

1. Enter an address
2. Choose an auto-suggested address
3. This gives us enough info to provide a quote based on a carrier (given the user's preferences)

![](0.png)
![](0-1.png)

After release, the problem we discovered is that the addresses being entered by some users were not showing up in the autocomplete. We *thought* we had properly accounted for this edge case during the design phase by providing an action in the case of 0 auto-suggested addresses. This action allowed informed the user he or she could continue to get a quote by entering the state of the property rather than the address.

![](/qqs-no-auto-suggestions.png)

However, what we discovered once we rolled this out to production was that some users could not get 

1. Hit Google’s place autocomplete API, which allows you to enter a natural lannguage address and get back the component pars of an address (verified through Google), i.e. "760 E 3rd Ave Salt Lake City" will give you back "address: 760 E 3rd Ave; city: Salt Lake City; state: UT; zip: 84103" broken into their respective pieces for ease of handling from a programatic perspective.
2. Using the address given back by Google, we would then hit the geocoding API to get the lat/long values for a particular property. 

The problem was, we found, that sometimes users couldn't find their address through step 1 but their address would be found through step 2. I will spare the technical details of how this is possible, but suffice it to say that it happened more frequently than you would think. For example, many times when people are getting insurance they are doing it on a newer property which may not be in a system like Google’s (yet).

What we decided to do was allow the user to fully enter an address and do a manual search for it. So if you started typing in an address and you saw yours come up in the autosuggest, you would choose it, which then does steps 1 and 2. But if you didn't see your address show up, you could still enter your full address and then do a manual search (step 2).

